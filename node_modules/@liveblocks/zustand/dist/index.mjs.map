{"version":3,"sources":["../src/index.ts","../src/version.ts"],"sourcesContent":["import type {\n  BaseUserMeta,\n  Client,\n  Json,\n  JsonObject,\n  LiveObject,\n  LsonObject,\n  Room,\n  Status,\n  User,\n} from \"@liveblocks/client\";\nimport type { LegacyConnectionStatus, StorageUpdate } from \"@liveblocks/core\";\nimport {\n  detectDupes,\n  errorIf,\n  legacy_patchImmutableObject,\n  lsonToJson,\n  patchLiveObjectKey,\n} from \"@liveblocks/core\";\nimport type { StateCreator, StoreMutatorIdentifier } from \"zustand\";\n\nimport { PKG_FORMAT, PKG_NAME, PKG_VERSION } from \"./version\";\n\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\nconst ERROR_PREFIX = \"Invalid @liveblocks/zustand middleware config.\";\n\nfunction mappingToFunctionIsNotAllowed(key: string): Error {\n  return new Error(\n    `${ERROR_PREFIX} mapping.${key} is invalid. Mapping to a function is not allowed.`\n  );\n}\n\nexport type LiveblocksContext<\n  TPresence extends JsonObject,\n  TStorage extends LsonObject,\n  TUserMeta extends BaseUserMeta,\n  TRoomEvent extends Json,\n> = {\n  /**\n   * Enters a room and starts sync it with zustand state\n   * @param roomId The id of the room\n   */\n  readonly enterRoom: (roomId: string) => () => void;\n  /**\n   * Leaves the currently entered room and stops sync it with zustand state, if\n   * any. If enterRoom was not called before, this is a no-op.\n   */\n  readonly leaveRoom: () => void;\n  /**\n   * The room currently synced to your zustand state.\n   */\n  readonly room: Room<TPresence, TStorage, TUserMeta, TRoomEvent> | null;\n  /**\n   * Other users in the room. Empty no room is currently synced\n   */\n  readonly others: readonly User<TPresence, TUserMeta>[];\n  /**\n   * Whether or not the room storage is currently loading\n   */\n  readonly isStorageLoading: boolean;\n  /**\n   * Legacy connection status of the room.\n   *\n   * @deprecated This API will be removed in a future version of Liveblocks.\n   * Prefer using the newer `.status` property.\n   *\n   * We recommend making the following changes if you use these APIs:\n   *\n   *     OLD STATUSES         NEW STATUSES\n   *     closed          -->  initial\n   *     authenticating  -->  connecting\n   *     connecting      -->  connecting\n   *     open            -->  connected\n   *     unavailable     -->  reconnecting\n   *     failed          -->  disconnected\n   */\n  readonly connection: LegacyConnectionStatus;\n  /**\n   * Connection status of the room.\n   */\n  readonly status: Status;\n};\n\n/**\n * @deprecated Renamed to WithLiveblocks<...>\n */\nexport type LiveblocksState<\n  TState,\n  TPresence extends JsonObject = JsonObject,\n  TStorage extends LsonObject = LsonObject,\n  TUserMeta extends BaseUserMeta = BaseUserMeta,\n  TRoomEvent extends Json = Json,\n> = WithLiveblocks<TState, TPresence, TStorage, TUserMeta, TRoomEvent>;\n\n/**\n * Adds the `liveblocks` property to your custom Zustand state.\n */\nexport type WithLiveblocks<\n  TState,\n  TPresence extends JsonObject = JsonObject,\n  TStorage extends LsonObject = LsonObject,\n  TUserMeta extends BaseUserMeta = BaseUserMeta,\n  TRoomEvent extends Json = Json,\n> = TState & {\n  readonly liveblocks: LiveblocksContext<\n    TPresence,\n    TStorage,\n    TUserMeta,\n    TRoomEvent\n  >;\n};\n\nexport type Mapping<T> = {\n  [K in keyof T]?: boolean;\n};\n\ntype Options<T> = {\n  /**\n   * Liveblocks client created by @liveblocks/client createClient\n   */\n  client: Client;\n  /**\n   * Mapping used to synchronize a part of your zustand state with one Liveblocks Room storage.\n   */\n  storageMapping?: Mapping<T>;\n  /**\n   * Mapping used to synchronize a part of your zustand state with one Liveblocks Room presence.\n   */\n  presenceMapping?: Mapping<T>;\n};\n\ntype OuterLiveblocksMiddleware = <\n  TState,\n  Mps extends [StoreMutatorIdentifier, unknown][] = [],\n  Mcs extends [StoreMutatorIdentifier, unknown][] = [],\n>(\n  config: StateCreator<TState, Mps, Mcs, Omit<TState, \"liveblocks\">>,\n  options: Options<Omit<TState, \"liveblocks\">>\n) => StateCreator<TState, Mps, Mcs, TState>;\n\ntype InnerLiveblocksMiddleware = <\n  TState extends {\n    readonly liveblocks: LiveblocksContext<\n      JsonObject,\n      LsonObject,\n      BaseUserMeta,\n      Json\n    >;\n  },\n>(\n  config: StateCreator<TState, [], []>,\n  options: Options<TState>\n) => StateCreator<TState, [], []>;\n\ntype ExtractPresence<\n  TRoom extends Room<JsonObject, LsonObject, BaseUserMeta, Json>,\n> = TRoom extends Room<infer P, any, any, any> ? P : never;\n\ntype ExtractStorage<\n  TRoom extends Room<JsonObject, LsonObject, BaseUserMeta, Json>,\n> = TRoom extends Room<any, infer S, any, any> ? S : never;\n\nconst middlewareImpl: InnerLiveblocksMiddleware = (config, options) => {\n  type TState = ReturnType<typeof config>;\n  type TLiveblocksContext = TState[\"liveblocks\"];\n  type TRoom = NonNullable<TLiveblocksContext[\"room\"]>;\n  type TPresence = ExtractPresence<TRoom>;\n  type TStorage = ExtractStorage<TRoom>;\n\n  const { client, presenceMapping, storageMapping } = validateOptions(options);\n  return (set, get, api) => {\n    let maybeRoom: TRoom | null = null;\n    let isPatching: boolean = false;\n    let storageRoot: LiveObject<TStorage> | null = null;\n    let unsubscribeCallbacks: Array<() => void> = [];\n    let lastRoomId: string | null = null;\n    let lastLeaveFn: (() => void) | null = null;\n\n    function enterRoom(newRoomId: string): void {\n      if (lastRoomId === newRoomId) {\n        return;\n      }\n\n      lastRoomId = newRoomId;\n      if (lastLeaveFn !== null) {\n        // First leave the old room before entering a potential new one\n        lastLeaveFn();\n      }\n\n      const initialPresence = selectFields(\n        get(),\n        presenceMapping\n      ) as unknown as TPresence;\n\n      const { room, leave } = client.enterRoom(newRoomId, {\n        initialPresence,\n      }) as unknown as { room: TRoom; leave: () => void };\n      maybeRoom = room;\n\n      updateLiveblocksContext(set, { isStorageLoading: true, room });\n\n      unsubscribeCallbacks.push(\n        room.events.others.subscribe(({ others }) => {\n          updateLiveblocksContext(set, { others });\n        })\n      );\n\n      unsubscribeCallbacks.push(\n        room.events.status.subscribe((status) => {\n          updateLiveblocksContext(set, {\n            status,\n            connection: room.getConnectionState(), // For backward-compatibility\n          });\n        })\n      );\n\n      unsubscribeCallbacks.push(\n        room.events.myPresence.subscribe(() => {\n          if (isPatching === false) {\n            set(\n              selectFields(\n                room.getPresence(),\n                presenceMapping\n              ) as Partial<TState>\n            );\n          }\n        })\n      );\n\n      void room.getStorage().then(({ root }) => {\n        const updates = {} as Partial<TState>;\n\n        room.batch(() => {\n          for (const key in storageMapping) {\n            const liveblocksStatePart = root.get(key);\n            if (liveblocksStatePart === undefined) {\n              updates[key] = get()[key];\n              patchLiveObjectKey(root, key, undefined, get()[key]);\n            } else {\n              updates[key] = lsonToJson(\n                liveblocksStatePart\n              ) as unknown as TState[Extract<keyof TState, string>];\n            }\n          }\n        });\n\n        set(updates);\n\n        storageRoot = root as LiveObject<TStorage>;\n        unsubscribeCallbacks.push(\n          room.subscribe(\n            root,\n            (updates) => {\n              if (isPatching === false) {\n                set(patchState(get(), updates, storageMapping));\n              }\n            },\n            { isDeep: true }\n          )\n        );\n\n        // set isLoading storage to false once storage is loaded\n        updateLiveblocksContext(set, {\n          isStorageLoading: false,\n        });\n      });\n\n      lastLeaveFn = () => {\n        for (const unsubscribe of unsubscribeCallbacks) {\n          unsubscribe();\n        }\n        unsubscribeCallbacks = [];\n\n        storageRoot = null;\n        maybeRoom = null;\n        isPatching = false;\n\n        lastRoomId = null;\n        lastLeaveFn = null;\n        leave();\n\n        updateLiveblocksContext(set, {\n          others: [],\n          connection: \"closed\",\n          isStorageLoading: false,\n          room: null,\n        });\n      };\n    }\n\n    function leaveRoom() {\n      lastLeaveFn?.();\n    }\n\n    const store = config(\n      (args) => {\n        const { liveblocks: _, ...oldState } = get();\n        set(args);\n        const { liveblocks: __, ...newState } = get();\n\n        if (maybeRoom) {\n          const room = maybeRoom;\n          isPatching = true;\n          updatePresence(room, oldState, newState, presenceMapping);\n\n          room.batch(() => {\n            if (storageRoot) {\n              patchLiveblocksStorage(\n                storageRoot,\n                oldState,\n                newState,\n                storageMapping\n              );\n            }\n          });\n\n          isPatching = false;\n        }\n      },\n      get,\n      api\n    );\n\n    return {\n      ...store,\n      liveblocks: {\n        enterRoom,\n        leaveRoom,\n        room: null,\n        others: [],\n        connection: \"closed\",\n        isStorageLoading: false,\n      },\n    };\n  };\n};\n\nexport const liveblocks =\n  middlewareImpl as unknown as OuterLiveblocksMiddleware;\n\n/**\n * @deprecated Renamed to `liveblocks`.\n */\nexport const middleware = liveblocks;\n\nfunction patchState<T>(\n  state: T,\n  updates: StorageUpdate[],\n  mapping: Mapping<T>\n) {\n  const partialState: Partial<T> = {};\n\n  for (const key in mapping) {\n    partialState[key] = state[key];\n  }\n\n  const patched = legacy_patchImmutableObject(partialState, updates);\n\n  const result: Partial<T> = {};\n\n  for (const key in mapping) {\n    result[key] = patched[key];\n  }\n\n  return result;\n}\n\nfunction selectFields<TState>(\n  presence: TState,\n  mapping: Mapping<TState>\n): /* TODO: Actually, Pick<TState, keyof Mapping<TState>> ? */\nPartial<TState> {\n  const partialState = {} as Partial<TState>;\n  for (const key in mapping) {\n    partialState[key] = presence[key];\n  }\n  return partialState;\n}\n\nfunction updateLiveblocksContext<\n  TState,\n  TPresence extends JsonObject,\n  TStorage extends LsonObject,\n  TUserMeta extends BaseUserMeta,\n  TRoomEvent extends Json,\n>(\n  set: (\n    callbackOrPartial: (\n      current: WithLiveblocks<\n        TState,\n        TPresence,\n        TStorage,\n        TUserMeta,\n        TRoomEvent\n      >\n    ) =>\n      | WithLiveblocks<TState, TPresence, TStorage, TUserMeta, TRoomEvent>\n      | Partial<any>\n  ) => void,\n  partial: Partial<\n    LiveblocksContext<TPresence, TStorage, TUserMeta, TRoomEvent>\n  >\n) {\n  set((state) => ({ liveblocks: { ...state.liveblocks, ...partial } }));\n}\n\nfunction updatePresence<\n  TPresence extends JsonObject,\n  TStorage extends LsonObject,\n  TUserMeta extends BaseUserMeta,\n  TRoomEvent extends Json,\n>(\n  room: Room<TPresence, TStorage, TUserMeta, TRoomEvent>,\n  oldState: TPresence,\n  newState: TPresence,\n  presenceMapping: Mapping<TPresence>\n) {\n  for (const key in presenceMapping) {\n    if (typeof newState[key] === \"function\") {\n      throw mappingToFunctionIsNotAllowed(key);\n    }\n\n    if (oldState[key] !== newState[key]) {\n      const val = newState?.[key];\n      const patch = {} as Partial<TPresence>;\n      patch[key] = val;\n      room.updatePresence(patch);\n    }\n  }\n}\n\nfunction patchLiveblocksStorage<O extends LsonObject, TState>(\n  root: LiveObject<O>,\n  oldState: TState,\n  newState: TState,\n  mapping: Mapping<TState>\n) {\n  for (const key in mapping) {\n    if (\n      process.env.NODE_ENV !== \"production\" &&\n      typeof newState[key] === \"function\"\n    ) {\n      throw mappingToFunctionIsNotAllowed(key);\n    }\n\n    if (oldState[key] !== newState[key]) {\n      const oldVal = oldState[key];\n      const newVal = newState[key];\n      patchLiveObjectKey(root, key, oldVal, newVal);\n    }\n  }\n}\n\nfunction isObject(value: unknown): value is object {\n  return Object.prototype.toString.call(value) === \"[object Object]\";\n}\n\nfunction validateNoDuplicateKeys<T>(\n  storageMapping: Mapping<T>,\n  presenceMapping: Mapping<T>\n) {\n  for (const key in storageMapping) {\n    if (presenceMapping[key] !== undefined) {\n      throw new Error(\n        `${ERROR_PREFIX} \"${key}\" is mapped on both presenceMapping and storageMapping. A key shouldn't exist on both mapping.`\n      );\n    }\n  }\n}\n\n/**\n * Remove false keys from mapping and generate to a new object to avoid potential mutation from outside the middleware\n */\nfunction validateMapping<T>(\n  mapping: Mapping<T>,\n  mappingType: \"storageMapping\" | \"presenceMapping\"\n): Mapping<T> {\n  errorIf(\n    !isObject(mapping),\n    `${ERROR_PREFIX} ${mappingType} should be an object where the values are boolean.`\n  );\n\n  const result: Mapping<T> = {};\n  for (const key in mapping) {\n    errorIf(\n      typeof mapping[key] !== \"boolean\",\n      `${ERROR_PREFIX} ${mappingType}.${key} value should be a boolean`\n    );\n\n    if (mapping[key] === true) {\n      result[key] = true;\n    }\n  }\n  return result;\n}\n\nfunction validateOptions<TState>(options: Options<TState>): {\n  client: Client;\n  presenceMapping: Mapping<TState>;\n  storageMapping: Mapping<TState>;\n} {\n  const client = options.client;\n  errorIf(!client, `${ERROR_PREFIX} client is missing`);\n\n  const storageMapping = validateMapping(\n    options.storageMapping ?? {},\n    \"storageMapping\"\n  );\n\n  const presenceMapping = validateMapping(\n    options.presenceMapping ?? {},\n    \"presenceMapping\"\n  );\n\n  if (process.env.NODE_ENV !== \"production\") {\n    validateNoDuplicateKeys(storageMapping, presenceMapping);\n  }\n\n  return { client, storageMapping, presenceMapping };\n}\n","declare const __VERSION__: string;\ndeclare const TSUP_FORMAT: string;\n\nexport const PKG_NAME = \"@liveblocks/zustand\";\nexport const PKG_VERSION = typeof __VERSION__ === \"string\" && __VERSION__;\nexport const PKG_FORMAT = typeof TSUP_FORMAT === \"string\" && TSUP_FORMAT;\n"],"mappings":"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","names":["updates"]}