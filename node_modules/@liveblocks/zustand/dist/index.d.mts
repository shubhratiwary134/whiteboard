import { JsonObject, LsonObject, BaseUserMeta, Json, Room, User, Status, Client } from '@liveblocks/client';
import { LegacyConnectionStatus } from '@liveblocks/core';
import { StoreMutatorIdentifier, StateCreator } from 'zustand';

declare type LiveblocksContext<TPresence extends JsonObject, TStorage extends LsonObject, TUserMeta extends BaseUserMeta, TRoomEvent extends Json> = {
    /**
     * Enters a room and starts sync it with zustand state
     * @param roomId The id of the room
     */
    readonly enterRoom: (roomId: string) => () => void;
    /**
     * Leaves the currently entered room and stops sync it with zustand state, if
     * any. If enterRoom was not called before, this is a no-op.
     */
    readonly leaveRoom: () => void;
    /**
     * The room currently synced to your zustand state.
     */
    readonly room: Room<TPresence, TStorage, TUserMeta, TRoomEvent> | null;
    /**
     * Other users in the room. Empty no room is currently synced
     */
    readonly others: readonly User<TPresence, TUserMeta>[];
    /**
     * Whether or not the room storage is currently loading
     */
    readonly isStorageLoading: boolean;
    /**
     * Legacy connection status of the room.
     *
     * @deprecated This API will be removed in a future version of Liveblocks.
     * Prefer using the newer `.status` property.
     *
     * We recommend making the following changes if you use these APIs:
     *
     *     OLD STATUSES         NEW STATUSES
     *     closed          -->  initial
     *     authenticating  -->  connecting
     *     connecting      -->  connecting
     *     open            -->  connected
     *     unavailable     -->  reconnecting
     *     failed          -->  disconnected
     */
    readonly connection: LegacyConnectionStatus;
    /**
     * Connection status of the room.
     */
    readonly status: Status;
};
/**
 * @deprecated Renamed to WithLiveblocks<...>
 */
declare type LiveblocksState<TState, TPresence extends JsonObject = JsonObject, TStorage extends LsonObject = LsonObject, TUserMeta extends BaseUserMeta = BaseUserMeta, TRoomEvent extends Json = Json> = WithLiveblocks<TState, TPresence, TStorage, TUserMeta, TRoomEvent>;
/**
 * Adds the `liveblocks` property to your custom Zustand state.
 */
declare type WithLiveblocks<TState, TPresence extends JsonObject = JsonObject, TStorage extends LsonObject = LsonObject, TUserMeta extends BaseUserMeta = BaseUserMeta, TRoomEvent extends Json = Json> = TState & {
    readonly liveblocks: LiveblocksContext<TPresence, TStorage, TUserMeta, TRoomEvent>;
};
declare type Mapping<T> = {
    [K in keyof T]?: boolean;
};
declare type Options<T> = {
    /**
     * Liveblocks client created by @liveblocks/client createClient
     */
    client: Client;
    /**
     * Mapping used to synchronize a part of your zustand state with one Liveblocks Room storage.
     */
    storageMapping?: Mapping<T>;
    /**
     * Mapping used to synchronize a part of your zustand state with one Liveblocks Room presence.
     */
    presenceMapping?: Mapping<T>;
};
declare type OuterLiveblocksMiddleware = <TState, Mps extends [StoreMutatorIdentifier, unknown][] = [], Mcs extends [StoreMutatorIdentifier, unknown][] = []>(config: StateCreator<TState, Mps, Mcs, Omit<TState, "liveblocks">>, options: Options<Omit<TState, "liveblocks">>) => StateCreator<TState, Mps, Mcs, TState>;
declare const liveblocks: OuterLiveblocksMiddleware;
/**
 * @deprecated Renamed to `liveblocks`.
 */
declare const middleware: OuterLiveblocksMiddleware;

export { type LiveblocksContext, type LiveblocksState, type Mapping, type WithLiveblocks, liveblocks, middleware };
