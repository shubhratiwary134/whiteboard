// src/index.ts
import {
  detectDupes,
  errorIf,
  legacy_patchImmutableObject,
  lsonToJson,
  patchLiveObjectKey
} from "@liveblocks/core";

// src/version.ts
var PKG_NAME = "@liveblocks/zustand";
var PKG_VERSION = "1.12.0";
var PKG_FORMAT = "esm";

// src/index.ts
detectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);
var ERROR_PREFIX = "Invalid @liveblocks/zustand middleware config.";
function mappingToFunctionIsNotAllowed(key) {
  return new Error(
    `${ERROR_PREFIX} mapping.${key} is invalid. Mapping to a function is not allowed.`
  );
}
var middlewareImpl = (config, options) => {
  const { client, presenceMapping, storageMapping } = validateOptions(options);
  return (set, get, api) => {
    let maybeRoom = null;
    let isPatching = false;
    let storageRoot = null;
    let unsubscribeCallbacks = [];
    let lastRoomId = null;
    let lastLeaveFn = null;
    function enterRoom(newRoomId) {
      if (lastRoomId === newRoomId) {
        return;
      }
      lastRoomId = newRoomId;
      if (lastLeaveFn !== null) {
        lastLeaveFn();
      }
      const initialPresence = selectFields(
        get(),
        presenceMapping
      );
      const { room, leave } = client.enterRoom(newRoomId, {
        initialPresence
      });
      maybeRoom = room;
      updateLiveblocksContext(set, { isStorageLoading: true, room });
      unsubscribeCallbacks.push(
        room.events.others.subscribe(({ others }) => {
          updateLiveblocksContext(set, { others });
        })
      );
      unsubscribeCallbacks.push(
        room.events.status.subscribe((status) => {
          updateLiveblocksContext(set, {
            status,
            connection: room.getConnectionState()
            // For backward-compatibility
          });
        })
      );
      unsubscribeCallbacks.push(
        room.events.myPresence.subscribe(() => {
          if (isPatching === false) {
            set(
              selectFields(
                room.getPresence(),
                presenceMapping
              )
            );
          }
        })
      );
      void room.getStorage().then(({ root }) => {
        const updates = {};
        room.batch(() => {
          for (const key in storageMapping) {
            const liveblocksStatePart = root.get(key);
            if (liveblocksStatePart === void 0) {
              updates[key] = get()[key];
              patchLiveObjectKey(root, key, void 0, get()[key]);
            } else {
              updates[key] = lsonToJson(
                liveblocksStatePart
              );
            }
          }
        });
        set(updates);
        storageRoot = root;
        unsubscribeCallbacks.push(
          room.subscribe(
            root,
            (updates2) => {
              if (isPatching === false) {
                set(patchState(get(), updates2, storageMapping));
              }
            },
            { isDeep: true }
          )
        );
        updateLiveblocksContext(set, {
          isStorageLoading: false
        });
      });
      lastLeaveFn = () => {
        for (const unsubscribe of unsubscribeCallbacks) {
          unsubscribe();
        }
        unsubscribeCallbacks = [];
        storageRoot = null;
        maybeRoom = null;
        isPatching = false;
        lastRoomId = null;
        lastLeaveFn = null;
        leave();
        updateLiveblocksContext(set, {
          others: [],
          connection: "closed",
          isStorageLoading: false,
          room: null
        });
      };
    }
    function leaveRoom() {
      lastLeaveFn?.();
    }
    const store = config(
      (args) => {
        const { liveblocks: _, ...oldState } = get();
        set(args);
        const { liveblocks: __, ...newState } = get();
        if (maybeRoom) {
          const room = maybeRoom;
          isPatching = true;
          updatePresence(room, oldState, newState, presenceMapping);
          room.batch(() => {
            if (storageRoot) {
              patchLiveblocksStorage(
                storageRoot,
                oldState,
                newState,
                storageMapping
              );
            }
          });
          isPatching = false;
        }
      },
      get,
      api
    );
    return {
      ...store,
      liveblocks: {
        enterRoom,
        leaveRoom,
        room: null,
        others: [],
        connection: "closed",
        isStorageLoading: false
      }
    };
  };
};
var liveblocks = middlewareImpl;
var middleware = liveblocks;
function patchState(state, updates, mapping) {
  const partialState = {};
  for (const key in mapping) {
    partialState[key] = state[key];
  }
  const patched = legacy_patchImmutableObject(partialState, updates);
  const result = {};
  for (const key in mapping) {
    result[key] = patched[key];
  }
  return result;
}
function selectFields(presence, mapping) {
  const partialState = {};
  for (const key in mapping) {
    partialState[key] = presence[key];
  }
  return partialState;
}
function updateLiveblocksContext(set, partial) {
  set((state) => ({ liveblocks: { ...state.liveblocks, ...partial } }));
}
function updatePresence(room, oldState, newState, presenceMapping) {
  for (const key in presenceMapping) {
    if (typeof newState[key] === "function") {
      throw mappingToFunctionIsNotAllowed(key);
    }
    if (oldState[key] !== newState[key]) {
      const val = newState?.[key];
      const patch = {};
      patch[key] = val;
      room.updatePresence(patch);
    }
  }
}
function patchLiveblocksStorage(root, oldState, newState, mapping) {
  for (const key in mapping) {
    if (process.env.NODE_ENV !== "production" && typeof newState[key] === "function") {
      throw mappingToFunctionIsNotAllowed(key);
    }
    if (oldState[key] !== newState[key]) {
      const oldVal = oldState[key];
      const newVal = newState[key];
      patchLiveObjectKey(root, key, oldVal, newVal);
    }
  }
}
function isObject(value) {
  return Object.prototype.toString.call(value) === "[object Object]";
}
function validateNoDuplicateKeys(storageMapping, presenceMapping) {
  for (const key in storageMapping) {
    if (presenceMapping[key] !== void 0) {
      throw new Error(
        `${ERROR_PREFIX} "${key}" is mapped on both presenceMapping and storageMapping. A key shouldn't exist on both mapping.`
      );
    }
  }
}
function validateMapping(mapping, mappingType) {
  errorIf(
    !isObject(mapping),
    `${ERROR_PREFIX} ${mappingType} should be an object where the values are boolean.`
  );
  const result = {};
  for (const key in mapping) {
    errorIf(
      typeof mapping[key] !== "boolean",
      `${ERROR_PREFIX} ${mappingType}.${key} value should be a boolean`
    );
    if (mapping[key] === true) {
      result[key] = true;
    }
  }
  return result;
}
function validateOptions(options) {
  const client = options.client;
  errorIf(!client, `${ERROR_PREFIX} client is missing`);
  const storageMapping = validateMapping(
    options.storageMapping ?? {},
    "storageMapping"
  );
  const presenceMapping = validateMapping(
    options.presenceMapping ?? {},
    "presenceMapping"
  );
  if (process.env.NODE_ENV !== "production") {
    validateNoDuplicateKeys(storageMapping, presenceMapping);
  }
  return { client, storageMapping, presenceMapping };
}
export {
  liveblocks,
  middleware
};
//# sourceMappingURL=index.mjs.map